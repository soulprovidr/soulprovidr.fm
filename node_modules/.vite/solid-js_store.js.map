{
  "version": 3,
  "sources": ["../solid-js/store/dist/store.js"],
  "sourcesContent": ["import { $PROXY, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !obj.__proto__ || obj.__proto__ === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction ownKeys(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode() {\n  const [s, set] = createSignal(undefined, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n    return wrappable ? wrap$1(value) : value;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const array = Array.isArray(state);\n  const len = state.length;\n  const isUndefined = value === undefined;\n  const notify = array || isUndefined === property in state;\n  if (isUndefined) {\n    delete state[property];\n  } else state[property] = value;\n  let nodes = getDataNodes(state),\n      node;\n  (node = nodes[property]) && node.$();\n  if (array && state.length !== len) (node = nodes.length) && node.$();\n  notify && (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n      prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), [part[i]].concat(traversed));\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), [i].concat(traversed));\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), [i].concat(traversed));\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(store, options) {\n  const unwrappedStore = unwrap(store || {});\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => updatePath(unwrappedStore, args));\n  }\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    const value = target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    const wrappable = isWrappable(value);\n    if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property))) {\n      let nodes, node;\n      if (wrappable && (nodes = getDataNodes(value))) {\n        node = nodes._ || (nodes._ = createDataNode());\n        node();\n      }\n      nodes = getDataNodes(target);\n      node = nodes[property] || (nodes[property] = createDataNode());\n      node();\n    }\n    return wrappable ? wrap(value) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\n\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    target !== previous && setProperty(parent, property, target);\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n            newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return s => {\n    const state = s;\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    applyState(v, {\n      state\n    }, \"state\", merge, key);\n    return state;\n  };\n}\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    return isWrappable(value) ? new Proxy(value, setterTraps) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return s => {\n    const state = s;\n    if (isWrappable(state)) fn(new Proxy(state, setterTraps));\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, produce, reconcile, unwrap };\n"],
  "mappings": "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",
  "names": []
}
