import { $PROXY, Accessor } from "../..";
export declare const $RAW: unique symbol, $NODE: unique symbol, $NAME: unique symbol;
export declare type StoreNode = {
    [$NODE]?: any;
    [$PROXY]?: any;
    [$NAME]?: string;
    [k: string]: any;
    [k: number]: any;
};
declare type AddSymbolToPrimitive<T> = T extends {
    [Symbol.toPrimitive]: infer V;
} ? {
    [Symbol.toPrimitive]: V;
} : {};
declare type AddSymbolIterator<T> = T extends {
    [Symbol.iterator]: infer V;
} ? {
    [Symbol.iterator]: V;
} : {};
declare type AddSymbolToStringTag<T> = T extends {
    [Symbol.toStringTag]: infer V;
} ? {
    [Symbol.toStringTag]: V;
} : {};
declare type AddCallable<T> = T extends {
    (...x: any[]): infer V;
} ? {
    (...x: Parameters<T>): V;
} : {};
export declare type NotWrappable = string | number | boolean | Function | null;
export declare type Store<T> = {
    [P in keyof T]: T[P] extends object ? Store<T[P]> & T[P] : T[P];
} & {
    [$RAW]?: T;
} & AddSymbolToPrimitive<T> & AddSymbolIterator<T> & AddSymbolToStringTag<T> & AddCallable<T>;
export declare function isWrappable(obj: any): any;
export declare function unwrap<T extends StoreNode>(item: any, set?: Set<unknown>): T;
export declare function getDataNodes(target: StoreNode): any;
export declare function proxyDescriptor(target: StoreNode, property: string | number | symbol): PropertyDescriptor | undefined;
export declare function ownKeys(target: StoreNode): (string | symbol)[];
export declare function createDataNode(): Accessor<void> & {
    $: () => void;
};
export declare function setProperty(state: StoreNode, property: string | number, value: any): void;
export declare function updatePath(current: StoreNode, path: any[], traversed?: (number | string)[]): void;
export declare type Readonly<T> = {
    readonly [K in keyof T]: DeepReadonly<T[K]>;
};
export declare type DeepReadonly<T> = T extends [infer A] ? Readonly<[A]> : T extends [infer A, infer B] ? Readonly<[A, B]> : T extends [infer A, infer B, infer C] ? Readonly<[A, B, C]> : T extends [infer A, infer B, infer C, infer D] ? Readonly<[A, B, C, D]> : T extends [infer A, infer B, infer C, infer D, infer E] ? Readonly<[A, B, C, D, E]> : T extends [infer A, infer B, infer C, infer D, infer E, infer F] ? Readonly<[A, B, C, D, E, F]> : T extends [infer A, infer B, infer C, infer D, infer E, infer F, infer G] ? Readonly<[A, B, C, D, E, F, G]> : T extends [infer A, infer B, infer C, infer D, infer E, infer F, infer G, infer H] ? Readonly<[A, B, C, D, E, F, G, H]> : T extends object ? Readonly<T> : T;
export declare type StoreSetter<T> = Partial<T> | ((prevState: T extends NotWrappable ? T : Store<DeepReadonly<T>>, traversed?: (string | number)[]) => Partial<T | DeepReadonly<T>> | void);
export declare type StorePathRange = {
    from?: number;
    to?: number;
    by?: number;
};
export declare type ArrayFilterFn<T> = (item: T extends any[] ? T[number] : never, index: number) => boolean;
export declare type Part<T> = T extends any[] ? keyof T | Array<keyof T> | ArrayFilterFn<T> | StorePathRange : T extends object ? keyof T | Array<keyof T> : never;
export declare type NullableNext<T, K> = K extends keyof T ? T[K] : K extends Array<keyof T> ? T[K[number]] : T extends any[] ? K extends StorePathRange ? T[number] : K extends ArrayFilterFn<T> ? T[number] : never : never;
export declare type Next<T, K> = NonNullable<NullableNext<T, K>>;
export interface SetStoreFunction<T> {
    <Setter extends StoreSetter<T>>(...args: [Setter]): void;
    <K1 extends Part<T>, Setter extends StoreSetter<NullableNext<T, K1>>>(...args: [K1, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, Setter extends StoreSetter<NullableNext<Next<T, K1>, K2>>>(...args: [K1, K2, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, K3 extends Part<Next<Next<T, K1>, K2>>, Setter extends StoreSetter<NullableNext<Next<Next<T, K1>, K2>, K3>>>(...args: [K1, K2, K3, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, K3 extends Part<Next<Next<T, K1>, K2>>, K4 extends Part<Next<Next<Next<T, K1>, K2>, K3>>, Setter extends StoreSetter<NullableNext<Next<Next<Next<T, K1>, K2>, K3>, K4>>>(...args: [K1, K2, K3, K4, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, K3 extends Part<Next<Next<T, K1>, K2>>, K4 extends Part<Next<Next<Next<T, K1>, K2>, K3>>, K5 extends Part<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>>, Setter extends StoreSetter<NullableNext<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>>>(...args: [K1, K2, K3, K4, K5, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, K3 extends Part<Next<Next<T, K1>, K2>>, K4 extends Part<Next<Next<Next<T, K1>, K2>, K3>>, K5 extends Part<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>>, K6 extends Part<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>>, Setter extends StoreSetter<NullableNext<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>, K6>>>(...args: [K1, K2, K3, K4, K5, K6, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, K3 extends Part<Next<Next<T, K1>, K2>>, K4 extends Part<Next<Next<Next<T, K1>, K2>, K3>>, K5 extends Part<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>>, K6 extends Part<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>>, K7 extends Part<Next<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>, K6>>, Setter extends StoreSetter<NullableNext<Next<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>, K6>, K7>>>(...args: [K1, K2, K3, K4, K5, K6, K7, Setter]): void;
    <K1 extends Part<T>, K2 extends Part<Next<T, K1>>, K3 extends Part<Next<Next<T, K1>, K2>>, K4 extends Part<Next<Next<Next<T, K1>, K2>, K3>>, K5 extends Part<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>>, K6 extends Part<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>>, K7 extends Part<Next<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>, K6>>, K8 extends Part<Next<Next<Next<Next<Next<Next<Next<T, K1>, K2>, K3>, K4>, K5>, K6>, K7>>>(...args: [K1, K2, K3, K4, K5, K6, K7, K8, ...(Part<any> | StoreSetter<any>)[]]): void;
}
/**
 * creates a reactive store that can be read through a proxy object and written with a setter function
 *
 * @description https://www.solidjs.com/docs/latest/api#createstore
 */
export declare function createStore<T extends StoreNode>(store: T | Store<T>, options?: {
    name?: string;
}): [get: Store<T>, set: SetStoreFunction<T>];
export {};
