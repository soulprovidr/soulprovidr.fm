import { requestCallback } from "./scheduler";
import type { JSX } from "../jsx";
export declare type Accessor<T> = () => T;
export declare type Setter<T> = undefined extends T ? <U extends T>(v?: (U extends Function ? never : U) | ((prev?: T) => U)) => U : <U extends T>(v: (U extends Function ? never : U) | ((prev: T) => U)) => U;
export declare const equalFn: <T>(a: T, b: T) => boolean;
export declare const $PROXY: unique symbol;
export declare const NOTPENDING: {};
export declare var Owner: Owner | null;
export declare let Transition: Transition | null;
declare global {
    var _$afterUpdate: () => void;
}
interface Signal<T> {
    value?: T;
    observers: Computation<any>[] | null;
    observerSlots: number[] | null;
    pending: T | {};
    tValue?: T;
    comparator?: (prev: T, next: T) => boolean;
    name?: string;
}
interface Owner {
    owned: Computation<any>[] | null;
    cleanups: (() => void)[] | null;
    owner: Owner | null;
    context: any | null;
    sourceMap?: Record<string, {
        value: unknown;
    }>;
    name?: string;
    componentName?: string;
}
interface Computation<T> extends Owner {
    fn: (v?: T) => T;
    state: number;
    tState?: number;
    sources: Signal<T>[] | null;
    sourceSlots: number[] | null;
    value?: T;
    updatedAt: number | null;
    pure: boolean;
    user?: boolean;
    suspense?: SuspenseContextType;
}
interface Memo<T> extends Signal<T>, Computation<T> {
    tOwned?: Computation<any>[];
}
interface Transition {
    sources: Set<Signal<any>>;
    effects: Computation<any>[];
    promises: Set<Promise<any>>;
    disposed: Set<Computation<any>>;
    queue: Set<Computation<any>>;
    scheduler?: (fn: () => void) => unknown;
    running: boolean;
    cb: (() => void)[];
}
/**
 * Creates a new non-tracked reactive context that doesn't auto-dispose
 *
 * @param fn a function in which the reactive state is scoped
 * @param detachedOwner optional reactive context to bind the root to
 * @returns the output of `fn`.
 *
 * @description https://www.solidjs.com/docs/latest/api#createroot
 */
export declare function createRoot<T>(fn: (dispose: () => void) => T, detachedOwner?: Owner): T;
export declare type SignalOptions<T> = {
    name?: string;
    equals?: false | ((prev: T, next: T) => boolean);
};
/**
 * Creates a simple reactive state with a getter and setter
 * ```typescript
 * const [state: Accessor<T>, setState: Setter<T>] = createSignal<T>(
 *  value: T,
 *  options?: { name?: string, equals?: false | ((prev: T, next: T) => boolean) }
 * )
 * ```
 * @param value initial value of the state; if empty, the state's type will automatically extended with undefined; otherwise you need to extend the type manually if you want setting to undefined not be an error
 * @param options optional object with a name for debugging purposes and equals, a comparator function for the previous and next value to allow fine-grained control over the reactivity
 *
 * @returns ```typescript
 * [state: Accessor<T>, setState: Setter<T>]
 * ```
 * * the Accessor is merely a function that returns the current value and registers each call to the reactive root
 * * the Setter is a function that allows directly setting or mutating the value:
 * ```typescript
 * const [count, setCount] = createSignal(0);
 * setCount(count => count + 1);
 * ```
 *
 * @description https://www.solidjs.com/docs/latest/api#createsignal
 */
export declare function createSignal<T>(): [get: Accessor<T | undefined>, set: Setter<T | undefined>];
export declare function createSignal<T>(value: T, options?: {
    equals?: false | ((prev: T, next: T) => boolean);
    name?: string;
    internal?: boolean;
}): [get: Accessor<T>, set: Setter<T>];
/**
 * Creates a reactive computation that runs immediately before render, mainly used to write to other reactive primitives
 * ```typescript
 * export function createComputed<T>(
 *   fn: (v: T) => T,
 *   value?: T,
 *   options?: { name?: string }
 * ): void;
 * ```
 * @param fn a function that receives its previous or the initial value, if set, and returns a new value used to react on a computation
 * @param value an optional initial value for the computation; if set, fn will never receive undefined as first argument
 * @param options allows to set a name in dev mode for debugging purposes
 *
 * @description https://www.solidjs.com/docs/latest/api#createcomputed
 */
export declare function createComputed<T>(fn: (v?: T) => T | undefined): void;
export declare function createComputed<T>(fn: (v: T) => T, value: T, options?: {
    name?: string;
}): void;
/**
 * Creates a reactive computation that runs during the render phase as DOM elements are created and updated but not necessarily connected
 * ```typescript
 * export function createRenderEffect<T>(
 *   fn: (v: T) => T,
 *   value?: T,
 *   options?: { name?: string }
 * ): void;
 * ```
 * @param fn a function that receives its previous or the initial value, if set, and returns a new value used to react on a computation
 * @param value an optional initial value for the computation; if set, fn will never receive undefined as first argument
 * @param options allows to set a name in dev mode for debugging purposes
 *
 * @description https://www.solidjs.com/docs/latest/api#createrendereffect
 */
export declare function createRenderEffect<T>(fn: (v?: T) => T | undefined): void;
export declare function createRenderEffect<T>(fn: (v: T) => T, value: T, options?: {
    name?: string;
}): void;
/**
 * Creates a reactive computation that runs after the render phase
 * ```typescript
 * export function createEffect<T>(
 *   fn: (v: T) => T,
 *   value?: T,
 *   options?: { name?: string }
 * ): void;
 * ```
 * @param fn a function that receives its previous or the initial value, if set, and returns a new value used to react on a computation
 * @param value an optional initial value for the computation; if set, fn will never receive undefined as first argument
 * @param options allows to set a name in dev mode for debugging purposes
 *
 * @description https://www.solidjs.com/docs/latest/api#createeffect
 */
export declare function createEffect<T>(fn: (v?: T) => T | undefined): void;
export declare function createEffect<T>(fn: (v: T) => T, value: T, options?: {
    name?: string;
}): void;
/**
 * Creates a readonly derived reactive memoized signal
 * ```typescript
 * export function createMemo<T>(
 *   fn: (v: T) => T,
 *   value?: T,
 *   options?: { name?: string, equals?: false | ((prev: T, next: T) => boolean) }
 * ): T;
 * ```
 * @param fn a function that receives its previous or the initial value, if set, and returns a new value used to react on a computation
 * @param value an optional initial value for the computation; if set, fn will never receive undefined as first argument
 * @param options allows to set a name in dev mode for debugging purposes and use a custom comparison function in equals
 *
 * @description https://www.solidjs.com/docs/latest/api#creatememo
 */
export declare function createMemo<T>(fn: (v?: T) => T, value?: undefined, options?: {
    equals?: false | ((prev: T, next: T) => boolean);
    name?: string;
}): Accessor<T>;
export declare function createMemo<T>(fn: (v: T) => T, value: T, options?: {
    equals?: false | ((prev: T, next: T) => boolean);
    name?: string;
}): Accessor<T>;
export interface Resource<T> extends Accessor<T> {
    loading: boolean;
    error: any;
}
export declare type ResourceActions<T> = {
    mutate: Setter<T>;
    refetch: () => void;
};
export declare type ResourceReturn<T> = [Resource<T>, ResourceActions<T>];
export declare type ResourceSource<S> = S | false | null | (() => S | false | null);
export declare type ResourceFetcher<S, T> = (k: S, getPrev: Accessor<T>) => T | Promise<T>;
export declare type ResourceOptions<T> = T extends undefined ? {
    initialValue?: T;
    name?: string;
} : {
    initialValue: T;
    name?: string;
};
/**
 * Creates a resource that wraps a repeated promise in a reactive pattern:
 * ```typescript
 * const [resource, { mutate, refetch }] = crateResource(source, fetcher, options);
 * ```
 * @param source - reactive data function to toggle the request, optional
 * @param fetcher - function that receives the source (or true) and an accessor for the last or initial value and returns a value or a Promise with the value:
 * ```typescript
 * const fetcher: ResourceFetcher<S, T, > = (
 *   sourceOutput: ReturnValue<typeof source>,
 *   getPrev: Accessor<T>
 * ) => T | Promise<T>;
 * ```
 * @param options - an optional object with the initialValue and the name (for debugging purposes)
 *
 * @returns ```typescript
 * [Resource<T>, { mutate: Setter<T>, refetch: () => void }]
 * ```
 *
 * * Setting an `initialValue` in the options will mean that both the prev() accessor and the resource should never return undefined (if that is wanted, you need to extend the type with undefined)
 * * `mutate` allows to manually overwrite the resource without calling the fetcher
 * * `refetch` will re-run the fetcher without changing the source
 *
 * @description https://www.solidjs.com/docs/latest/api#createresource
 */
export declare function createResource<T extends any, S = true>(fetcher: ResourceFetcher<S, T>, options?: ResourceOptions<undefined>): [Resource<T | undefined>, ResourceActions<T | undefined>];
export declare function createResource<T, S = true>(fetcher: ResourceFetcher<S, T>, options: ResourceOptions<T>): [Resource<T>, ResourceActions<T>];
export declare function createResource<T, S>(source: ResourceSource<S>, fetcher: ResourceFetcher<S, T>, options?: ResourceOptions<undefined>): [Resource<T | undefined>, ResourceActions<T | undefined>];
export declare function createResource<T, S>(source: ResourceSource<S>, fetcher: ResourceFetcher<S, T>, options: ResourceOptions<T>): [Resource<T>, ResourceActions<T>];
/**
 * Creates a reactive computation that only runs and notifies the reactive context when the browser is idle
 * ```typescript
 * export function createDeferred<T>(
 *   fn: (v: T) => T,
 *   value?: T,
 *   options?: { timeoutMs?: number, name?: string, equals?: false | ((prev: T, next: T) => boolean) }
 * ): () => T);
 * ```
 * @param fn a function that receives its previous or the initial value, if set, and returns a new value used to react on a computation
 * @param value an optional initial value for the computation; if set, fn will never receive undefined as first argument
 * @param options allows to set the timeout in milliseconds, use a custom comparison function and set a name in dev mode for debugging purposes
 *
 * @description https://www.solidjs.com/docs/latest/api#createdeferred
 */
export declare function createDeferred<T>(source: Accessor<T>, options?: {
    equals?: false | ((prev: T, next: T) => boolean);
    name?: string;
    timeoutMs?: number;
}): Accessor<T>;
/**
 * Creates a conditional signal that only notifies subscribers when entering or exiting their key matching the value
 * ```typescript
 * export function createSelector<T, U>(
 *   source: () => T
 *   fn: (a: U, b: T) => boolean,
 *   options?: { name?: string }
 * ): (k: U) => boolean;
 * ```
 * @param source
 * @param fn a function that receives its previous or the initial value, if set, and returns a new value used to react on a computation
 * @param options allows to set a name in dev mode for debugging purposes, optional
 *
 * ```typescript
 * const isSelected = createSelector(selectedId);
 * <For each={list()}>
 *   {(item) => <li classList={{ active: isSelected(item.id) }}>{item.name}</li>}
 * </For>
 * ```
 *
 * This makes the operation O(2) instead of O(n).
 *
 * @description https://www.solidjs.com/docs/latest/api#createselector
 */
export declare function createSelector<T, U>(source: Accessor<T>, fn?: (a: U, b: T) => boolean, options?: {
    name?: string;
}): (key: U) => boolean;
/**
 * Holds changes inside the block before the reactive context is updated
 * @param fn wraps the reactive updates that should be batched
 * @returns the return value from `fn`
 *
 * @description https://www.solidjs.com/docs/latest/api#batch
 */
export declare function batch<T>(fn: () => T): T;
/**
 * Ignores tracking context inside its scope
 * @param fn the scope that is out of the tracking context
 * @returns the return value of `fn`
 *
 * @description https://www.solidjs.com/docs/latest/api#untrack
 */
export declare function untrack<T>(fn: Accessor<T>): T;
export declare type ReturnTypes<T> = T extends (() => any)[] ? {
    [I in keyof T]: ReturnTypes<T[I]>;
} : T extends () => any ? ReturnType<T> : never;
/**
 * on - make dependencies of a computation explicit
 * ```typescript
 * export function on<T extends Array<() => any> | (() => any), U>(
 *   deps: T | T[],
 *   fn: (input: T, prevInput: T, prevValue?: U) => U,
 *   options?: { defer?: boolean } = {}
 * ): (prevValue?: U) => U | undefined;
 * ```
 * @param deps list of reactive dependencies or a single reactive dependency
 * @param fn computation on input; the current previous content(s) of input and the previous value are given as arguments and it returns a new value
 * @param options optional, allows deferred computation until at the end of the next change
 * ```typescript
 * createEffect(on(a, (v) => console.log(v, b())));
 *
 * // is equivalent to:
 * createEffect(() => {
 *   const v = a();
 *   untrack(() => console.log(v, b()));
 * });
 * ```
 *
 * @description https://www.solidjs.com/docs/latest/api#on
 */
export declare function on<T extends (() => any)[], U>(deps: [...T], fn: (input: ReturnTypes<T>, prevInput: ReturnTypes<T>, prevValue?: U) => U, options?: {
    defer?: boolean;
}): (prevValue?: U) => U;
export declare function on<T extends () => any, U>(deps: T, fn: (input: ReturnType<T>, prevInput: ReturnType<T>, prevValue?: U) => U, options?: {
    defer?: boolean;
}): (prevValue?: U) => U;
/**
 * onMount - run an effect only after initial render on mount
 * @param fn an effect that should run only once on mount
 *
 * @description https://www.solidjs.com/docs/latest/api#onmount
 */
export declare function onMount(fn: () => void): void;
/**
 * onCleanup - run an effect once before the reactive scope is disposed
 * @param fn an effect that should run only once on cleanup
 *
 * @description https://www.solidjs.com/docs/latest/api#oncleanup
 */
export declare function onCleanup(fn: () => void): () => void;
/**
 * onError - run an effect whenever an error is thrown within the context of the child scopes
 * @param fn an error handler that receives the error
 *
 * * If the error is thrown again inside the error handler, it will trigger the next available parent handler
 *
 * @description https://www.solidjs.com/docs/latest/api#onerror
 */
export declare function onError(fn: (err: any) => void): void;
export declare function getListener(): Computation<any> | null;
export declare function getOwner(): Owner | null;
export declare function runWithOwner(o: Owner, fn: () => any): any;
export declare function enableScheduling(scheduler?: typeof requestCallback): void;
export declare function startTransition(fn: () => void, cb?: () => void): void;
/**
 * ```typescript
 * export function useTransition(): [
 *   () => boolean,
 *   (fn: () => void, cb?: () => void) => void
 * ];
 * @returns a tuple; first value is an accessor if the transition is pending and a callback to start the transition
 *
 * @description https://www.solidjs.com/docs/latest/api#usetransition
 */
export declare function useTransition(): [Accessor<boolean>, (fn: () => void, cb?: () => void) => void];
export declare function resumeEffects(e: Computation<any>[]): void;
export declare function devComponent<T>(Comp: (props: T) => JSX.Element, props: T): JSX.Element;
export declare function hashValue(v: any): string;
export declare function registerGraph(name: string, value: {
    value: unknown;
}): string;
interface GraphRecord {
    [k: string]: GraphRecord | unknown;
}
export declare function serializeGraph(owner?: Owner | null): GraphRecord;
export interface Context<T> {
    id: symbol;
    Provider: (props: {
        value: T;
        children: any;
    }) => any;
    defaultValue: T;
}
/**
 * Creates a Context to handle a state scoped for the children of a component
 * ```typescript
 * interface Context<T> {
 *   id: symbol;
 *   Provider: (props: { value: T; children: any }) => any;
 *   defaultValue: T;
 * }
 * export function createContext<T>(defaultValue?: T): Context<T | undefined>;
 * ```
 * @param defaultValue optional default to inject into context
 * @returns The context that contains the Provider Component and that can be used with `useContext`
 *
 * @description https://www.solidjs.com/docs/latest/api#createcontext
 */
export declare function createContext<T>(): Context<T | undefined>;
export declare function createContext<T>(defaultValue: T): Context<T>;
/**
 * use a context to receive a scoped state from a parent's Context.Provider
 *
 * @param context Context object made by `createContext`
 * @returns the current or `defaultValue`, if present
 *
 * @description https://www.solidjs.com/docs/latest/api#usecontext
 */
export declare function useContext<T>(context: Context<T>): T;
/**
 * Resolves child elements to help interact with children
 *
 * @param fn an accessor for the children
 * @returns a accessor of the same children, but resolved
 *
 * @description https://www.solidjs.com/docs/latest/api#children
 */
export declare function children(fn: Accessor<JSX.Element>): Accessor<JSX.Element>;
declare type SuspenseContextType = {
    increment?: () => void;
    decrement?: () => void;
    inFallback?: () => boolean;
    effects?: Computation<any>[];
    resolved?: boolean;
};
export declare function getSuspenseContext(): Context<SuspenseContextType> & {
    active?(): boolean;
    increment?(): void;
    decrement?(): void;
};
export declare function readSignal(this: Signal<any> | Memo<any>): any;
export declare function writeSignal(node: Signal<any> | Memo<any>, value: any, isComp?: boolean): any;
export {};
