<html>
  <head>
    <link rel="stylesheet" href="css/receiver.css" media="screen" />
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <!-- Cast Debug Logger -->
    <script src="//www.gstatic.com/cast/sdk/libs/devtools/debug_layer/caf_receiver_logger.js"></script>
  </head>

  <style>
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    * {
      box-sizing: border-box;
    }

    html {
      background: white;
      color: black;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      height: 100%;
      width: 100%;
    }

    header {
      display: flex;
      height: 100px;
      align-items: center;
      justify-content: space-between;
      padding: 16px 48px;
      width: 100%;
    }

    .header__logo {
      width: 50px;
      height: 50px;
    }

    .header__title {
      display: flex;
      align-items: center;
      font-size: 32px;
      font-weight: 600;
      gap: 16px;
    }

    .live-icon {
      animation: fadeIn 0.8s alternate infinite;
      animation-fill-mode: backwards;
      background: red;
      border-radius: 50%;
      width: 10px;
      height: 10px;
    }

    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      flex: 1;
    }

    .container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      width: 50%;
    }

    .player {
      display: flex;
      align-items: center;
      gap: 36px;
    }

    .player__cover {
      width: 40%;
    }

    .player__cover img {
      aspect-ratio: 1;
      border-radius: 8px;
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
        0 1px 2px 0 rgba(0, 0, 0, 0.06);
      max-width: 100%;
    }

    footer {
      display: flex;
      align-items: center;
      gap: 32px;
      width: 100%;
      padding: 0 48px 32px;
    }

    .status {
      width: 100px;
      height: 100px;
    }

    .progress {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1;
      margin-top: 32px;
    }

    .progress__bar {
      position: relative;
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
    }

    .progress__fill {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: #0071eb;
      border-radius: 4px;
      width: 40%;
    }

    .progress__labels {
      display: flex;
      justify-content: space-between;
    }

    #title {
      font-size: 28px;
      font-weight: 600;
      line-height: 34px;
      margin: 0;
      white-space: nowrap;
    }

    #artist {
      font-size: 20px;
      font-weight: 400;
      line-height: 24px;
      margin: 2px 0 0;
      white-space: nowrap;
    }

    cast-media-player {
      visibility: hidden;
      z-index: -1;
    }
  </style>

  <body>
    <header>
      <div class="header__title">
        <span class="live-icon"></span>
        Live
      </div>
      <img class="header__logo" src="/logo.png" alt="Soul Provider Logo" />
    </header>

    <main>
      <div class="container">
        <div class="player">
          <div class="player__cover">
            <img id="cover" src="" alt="Cover" />
          </div>
          <div class="player__info">
            <div id="title">Title</div>
            <div id="artist">Artist</div>
          </div>
        </div>
      </div>
    </main>

    <footer>
      <div class="status">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="currentColor"
          viewbox="0 0 16 16"
        >
          <path
            d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"
          />
        </svg>
      </div>
      <div class="progress">
        <div class="progress__bar">
          <div class="progress__fill"></div>
        </div>
        <div class="progress__labels">
          <div class="progress__label progress__label">0:00</div>
          <div class="progress__label progress__label">0:00</div>
        </div>
      </div>
    </footer>

    <cast-media-player></cast-media-player>

    <script type="module">
      "use strict";

      const syncMetadata = fetch(
        "https://api.radioking.io/widget/radio/soulprovidr/track/current"
      )
        .then((response) => response.json())
        .then((data) => {
          cover.src = data.cover;
          title.innerText = data.title;
          artist.innerText = data.artist;
        });

      setInterval(syncMetadata, 10000);
      syncMetadata();

      /**
       * @fileoverview This sample demonstrates how to build your own Web Receiver for
       * use with Google Cast. The main receiver implementation is provided in this
       * file which sets up access to the CastReceiverContext and PlayerManager. Some
       * added functionality can be enabled by uncommenting some of the code blocks
       * below.
       */

      /*
       * Convenience variables to access the CastReceiverContext and PlayerManager.
       */
      const context = cast.framework.CastReceiverContext.getInstance();
      const playerManager = context.getPlayerManager();

      /*
       * Constant to be used for fetching media by entity from sample repository.
       */
      const ID_REGEX = "\/?([^\/]+)\/?$";

      /**
       * Debug Logger
       */
      const castDebugLogger = cast.debug.CastDebugLogger.getInstance();
      const LOG_RECEIVER_TAG = "Receiver";

      /*
       * WARNING: Make sure to turn off debug logger for production release as it
       * may expose details of your app.
       * Uncomment below line to enable debug logger, show a 'DEBUG MODE' tag at
       * top left corner and show debug overlay.
       */
      //  context.addEventListener(cast.framework.system.EventType.READY, () => {
      //   if (!castDebugLogger.debugOverlayElement_) {
      //     /**
      //      *  Enable debug logger and show a 'DEBUG MODE' tag at
      //      *  top left corner.
      //      */
      //       castDebugLogger.setEnabled(true);

      //     /**
      //      * Show debug overlay.
      //      */
      //       castDebugLogger.showDebugLogs(true);
      //   }
      // });

      /*
       * Set verbosity level for Core events.
       */
      castDebugLogger.loggerLevelByEvents = {
        "cast.framework.events.category.CORE": cast.framework.LoggerLevel.INFO,
        "cast.framework.events.EventType.MEDIA_STATUS":
          cast.framework.LoggerLevel.DEBUG,
      };

      if (!castDebugLogger.loggerLevelByTags) {
        castDebugLogger.loggerLevelByTags = {};
      }

      /*
       * Set verbosity level for custom tag.
       * Enables log messages for error, warn, info and debug.
       */
      castDebugLogger.loggerLevelByTags[LOG_RECEIVER_TAG] =
        cast.framework.LoggerLevel.DEBUG;

      /*
       * Example of how to listen for events on playerManager.
       */
      playerManager.addEventListener(
        cast.framework.events.EventType.ERROR,
        (event) => {
          castDebugLogger.error(
            LOG_RECEIVER_TAG,
            "Detailed Error Code - " + event.detailedErrorCode
          );
          if (event && event.detailedErrorCode == 905) {
            castDebugLogger.error(
              LOG_RECEIVER_TAG,
              "LOAD_FAILED: Verify the load request is set up " +
                "properly and the media is able to play."
            );
          }
        }
      );

      /*
       * Intercept the LOAD request to load and set the contentUrl.
       */
      playerManager.setMessageInterceptor(
        cast.framework.messages.MessageType.LOAD,
        (loadRequestData) => {
          castDebugLogger.debug(
            LOG_RECEIVER_TAG,
            `loadRequestData: ${JSON.stringify(loadRequestData)}`
          );

          // If the loadRequestData is incomplete, return an error message.
          if (!loadRequestData || !loadRequestData.media) {
            const error = new cast.framework.messages.ErrorData(
              cast.framework.messages.ErrorType.LOAD_FAILED
            );
            error.reason = cast.framework.messages.ErrorReason.INVALID_REQUEST;
            return error;
          }

          // Check all content source fields for the asset URL or ID.
          let source =
            loadRequestData.media.contentUrl ||
            loadRequestData.media.entity ||
            loadRequestData.media.contentId;

          // If there is no source or a malformed ID then return an error.
          if (!source || source == "" || !source.match(ID_REGEX)) {
            let error = new cast.framework.messages.ErrorData(
              cast.framework.messages.ErrorType.LOAD_FAILED
            );
            error.reason = cast.framework.messages.ErrorReason.INVALID_REQUEST;
            return error;
          }

          let sourceId = source.match(ID_REGEX)[1];

          // Optionally add breaks to the media information and set the contentUrl.
          return (
            Promise.resolve()
              // .then(() => addBreaks(loadRequestData.media)) // Uncomment to enable ads.
              .then(() => {
                // If the source is a url that points to an asset don't fetch from the
                // content repository.
                if (sourceId.includes(".")) {
                  castDebugLogger.debug(
                    LOG_RECEIVER_TAG,
                    "Interceptor received full URL"
                  );
                  loadRequestData.media.contentUrl = source;
                  return loadRequestData;
                } else {
                  // Fetch the contentUrl if provided an ID or entity URL.
                  castDebugLogger.debug(
                    LOG_RECEIVER_TAG,
                    "Interceptor received ID"
                  );
                  return loadRequestData;
                  // return MediaFetcher.fetchMediaInformationById(
                  //   sourceId
                  // ).then((mediaInformation) => {
                  //   loadRequestData.media = mediaInformation;
                  //   return loadRequestData;
                  // });
                }
              })
              .catch((errorMessage) => {
                let error = new cast.framework.messages.ErrorData(
                  cast.framework.messages.ErrorType.LOAD_FAILED
                );
                error.reason =
                  cast.framework.messages.ErrorReason.INVALID_REQUEST;
                castDebugLogger.error(LOG_RECEIVER_TAG, errorMessage);
                return error;
              })
          );
        }
      );

      /*
       * Configure the CastReceiverOptions.
       */
      const castReceiverOptions = new cast.framework.CastReceiverOptions();

      /*
       * Set the player configuration.
       */
      const playbackConfig = new cast.framework.PlaybackConfig();
      playbackConfig.autoResumeDuration = 5;
      castReceiverOptions.playbackConfig = playbackConfig;
      castDebugLogger.info(
        LOG_RECEIVER_TAG,
        `autoResumeDuration set to: ${playbackConfig.autoResumeDuration}`
      );

      /*
       * Set the SupportedMediaCommands.
       */
      castReceiverOptions.supportedCommands =
        cast.framework.messages.Command.ALL_BASIC_MEDIA |
        cast.framework.messages.Command.QUEUE_PREV |
        cast.framework.messages.Command.QUEUE_NEXT |
        cast.framework.messages.Command.STREAM_TRANSFER;

      context.start(castReceiverOptions);
    </script>
  </body>
</html>
